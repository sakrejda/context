


#' This module assumes that there might be multiple projects, merged in
#' a specific order and since a context ultimately defines _one_
#' project, they will be flattened so that all their components
#' contribute.  If there is a name conflict that makes some elements not
#' accessible a warning is issued.  This needs some more spec.
#' 
#' @param context the context to extract parameters from.
#' @return the (modified) context.
ALL_project_to_head <- function(context) {
  flat_project <- flatten_context(context[['project']])
  if (any(names(flat_project) %in% names(context))) {
    perps <- names(flat_project)[names(flat_project) %in% names(context)]
    msg <- paste("Name clash between 'project' context and root:\n",
           paste0("\t", perps, collapse="\n"), sep='')
    warning(msg)
  }
  context <- c(flat_project, context)
  return(context)
}

#' This module assumes that a given project _must_ have three
#' input/output directories: 1) data, which should be read-only to the
#' project; 2) input, which should be generated by munging the data; and
#' 3) output, which should be generated by analyzing the data.  The
#' distinction is somewhat artificial but broadly applicable to
#' analytical work. 
#'
#' The modifications to the context are as follows:
#'  1) Generate a root level 'data' item with the path to data.
#'  2) Generate a root level 'input' item with the path to the input.
#'  3) Generate a root level 'output' item with the path to the output.
#'  4) Generate a root level 'processed-input' item with a path to data
#'     derived from the input.
#'  5) Generate a root level 'processed-output' item with a path to data
#'     derived from the output.
#'
#' If a 'group' is specified in the context, it is included in the path
#' before the 'name' level.  This needs some more spec but hey, it works...
#' 
#' @param context the context to extract parameters from.
#' @return the (modified) context.
ALL_project_paths <- function(context) {
  norm_root <- normalizePath(context[['root']])
  if ('group' %in% names(context))
    group <- context[['group']]
  else 
    group <- ''
  name <- names(context[['project']])[names(context[['project']]) != 'root'][1]
  context[['data']] <- file.path(norm_root, context[['data_dir']], group, name) %>% test_normalize_create_dir
  context[['input']] <- file.path(norm_root, context[['input_dir']], group, name) %>% test_normalize_create_dir
  context[['processed-input']] <- file.path(context[['input']], 'processed') %>% test_normalize_create_dir
  context[['output']] <- file.path(norm_root, context[['output_dir']], group, name) %>% test_normalize_create_dir
  context[['processed-output']] <- file.path(context[['output']], 'processed') %>% test_normalize_create_dir
  return(context)
}

#' This R-specific module checks for elements in the context matching
#' the pattern for R options ("language::R.*::options"), reads those and
#' then sets them.  It only applies side-effects.
#'
#' @param context the context to extract parameters from.
#' @return the (unmodified) context.
R_options <- function(context) {
  opts <- get_elements(context, 'language::R.*::options')
  set_options(opts)
  return(context)
}

#' This R-specific module checks for elements in the context matching 
#' the pattern for R libraries ("language::R.*::require::library"),
#' reads those and then loads each one in order.
#' 
#' @param context the context to extract parameters from.
#' @return the (unmodified) context.
R_libraries <- function(context) {
  libs <- get_elements(context, 'language::R.*::require::library')
  for ( l in libs ) 
    load_libraries(l)
  return(context)
}

#' This R-specific module checks for elements in the context matching
#' the pattern for R functions ("language::R.*::require::function"),
#' reads those and then defines each one in the (global?) namespace.
#' 
#' @param context the context to extract parameters from.
#' @return the (unmodified) context.
R_functions <- function(context) {
  funs <- get_elements(context, 'language::R.*::require::function')
  for ( f in funs ) 
    define_functions(f)
  return(context)
}





